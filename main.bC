//Conway's game of life in bC
//By Carson Rueber 2023

//I don't think we can have an array of dynamic size, so we hard cap the number of cells at 256
//Also there is no 'const' keyword or precompiler defs, so you have to change every instance of the 
//Number 256 to change the size of the boards

//Always read from readCells, write to writeCells
int readCells[256];
int writeCells[256];

//Size of the board (that we care about)
int xSize:10;
int ySize:5;

//Note that strings appear to not be null-terminated by default
//So make sure you add a \0 to the end of everything you pass to this function
//Or it will print garbage
print(char str[]) {
	int q:0;
	while true do {
		if (str[q] == '\0') then {
			break;
		} else {
			outputc(str[q]);
		}
		q++;
	}
}

int boolToInt(bool val) {
	if val then {
		return 1;
	}
	return 0;
}

int coordToIdx(int x; int y) {
	return (y * xSize) + x;
}

//out[0] will be x, out[1] is y
idxToCoord(int idx; int out[]) {
	out[0] = idx % xSize;
	out[1] = (idx - out[0]) / xSize;
}


init() {
	int q:0;

	//Set boards to 0
	for q=0 to 256 do {
		readCells[q] = 0;
		writeCells[q] = 0;
	}
	
	//Set up a glider, basic test shape
	readCells[coordToIdx(3,1)] = 1;
	readCells[coordToIdx(3,2)] = 1;
	readCells[coordToIdx(3,3)] = 1;
	readCells[coordToIdx(2,3)] = 1;
	readCells[coordToIdx(1,2)] = 1;
}


//Update a singular cell using state from readCells, and writes into writeCells
updateCell(int idx) {
	int neighborCount:0;
	int x, y;
	int out[2];

	idxToCoord(idx, out);
	x = out[0];
	y = out[1];

	//Entries are 0 or 1, so adding is fine
	neighborCount += readCells[coordToIdx((x + 1) % xSize, (y + 1) % ySize)];
	neighborCount += readCells[coordToIdx((x + 1) % xSize, (y + 0) % ySize)];
	neighborCount += readCells[coordToIdx((x + 1) % xSize, (y - 1) % ySize)];

	neighborCount += readCells[coordToIdx((x + 0) % xSize, (y + 1) % ySize)];
	neighborCount += readCells[coordToIdx((x + 0) % xSize, (y - 1) % ySize)];

	neighborCount += readCells[coordToIdx((x - 1) % xSize, (y + 1) % ySize)];
	neighborCount += readCells[coordToIdx((x - 1) % xSize, (y + 0) % ySize)];
	neighborCount += readCells[coordToIdx((x - 1) % xSize, (y - 1) % ySize)];

	//If we are alive
	if readCells[idx] == 1 then {
		if neighborCount == 2 or neighborCount == 3 then {
			writeCells[idx] = 1;
		} else {
			writeCells[idx] = 0;
		}
	} else {
		//We are dead
		if neighborCount == 3 then {
			writeCells[idx] = 1;
		} else {
			writeCells[idx] = 0;
		}
	}
}

//Use state from readcells to update writeCells
//Does not do any swapping
update() {
	int x, y;
	for y=0 to ySize do {
		for x=0 to xSize do {
			updateCell(coordToIdx(x,y));
		}
	}
}

//Swaps the two boards
swapBoards() {
	//Arrays might be copied on assignment?
	int temp[256];
	temp = writeCells;
	writeCells = readCells;
	readCells = temp;
}

//Prints a board
printBoard(int board[]) {
	int x, y;
	for y=0 to ySize do {
		for x=0 to xSize do {
			if board[coordToIdx(x,y)] != 0 then {
				outputc('X');
			} else {
				outputc('_');
			}
		}
		outnl();
	}
}

main() {
	int ticksToGo:1;
	int q:0;
	init();

	while true do {
		for q = 0 to ticksToGo do {
			printBoard(readCells);
			update();
			swapBoards();
			print("----------------------------------\0");
			outnl();
		}
		ticksToGo = input();
		if ticksToGo == 0 then {
			return;
		}
	}
}